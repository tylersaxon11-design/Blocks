<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#121212">
    <title>Pulse Grid</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-bg: #1e1e24;
            --highlight: #00fff2;
            --text-color: #ffffff;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* THE MAGIC FIX: Lock the body so it can't scroll */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            position: fixed; /* This prevents scrolling on iOS/Android */
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            touch-action: none; /* Disable all native gestures */
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        /* --- UI Elements --- */
        #header-area {
            width: 100%;
            max-width: 500px;
            padding: 10px 20px 0 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
            z-index: 10;
        }

        .scores-row {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.08);
            padding: 5px 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 80px;
        }
        .label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; }
        .value { font-size: 1.3rem; font-weight: bold; }

        #pulse-bar {
            width: 100%;
            padding: 8px 0;
            background: #222;
            border-radius: 15px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid #444;
            text-transform: uppercase;
        }

        /* --- Canvas --- */
        #canvas-wrapper {
            flex-grow: 1; /* Take all remaining space */
            width: 100%;
            max-width: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        canvas {
            border-radius: 8px;
            background-color: var(--grid-bg);
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        /* --- Overlays --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18,18,18,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        h1 { font-size: 3rem; margin: 0; color: var(--highlight); text-shadow: 0 0 15px var(--highlight); }
        p { color: #ccc; margin: 15px 0; max-width: 300px; text-align: center; line-height: 1.4; }
        
        button {
            background: var(--highlight);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 30px;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(0,255,242,0.4);
        }
        button:active { transform: scale(0.95); }

        /* Pulse Modes */
        .pulse-normal { border-color: #555; color: #fff; }
        .pulse-gravity { border-color: #f39c12; color: #f39c12; background: rgba(243, 156, 18, 0.15); }
        .pulse-locked { border-color: #e74c3c; color: #e74c3c; background: rgba(231, 76, 60, 0.15); }
        .pulse-echo { border-color: #9b59b6; color: #9b59b6; background: rgba(155, 89, 182, 0.15); }

    </style>
</head>
<body>

<div id="game-container">
    
    <!-- UI Header -->
    <div id="header-area">
        <div class="scores-row">
            <div class="stat-box">
                <div class="label">Score</div>
                <div class="value" id="score-val">0</div>
            </div>
            <div class="stat-box">
                <div class="label">Best</div>
                <div class="value" id="highscore-val">0</div>
            </div>
        </div>
        <div id="pulse-bar" class="pulse-normal">STATUS: NORMAL</div>
    </div>

    <!-- Canvas Wrapper -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay">
        <h1>PULSE GRID</h1>
        <p>Drag blocks to fill the grid. Blocks float above your finger.</p>
        <button id="start-btn">TAP TO PLAY</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over" class="overlay hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 0 20px #e74c3c;">NO MOVES</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="Game.reset()">TRY AGAIN</button>
    </div>

</div>

<script>
/**
 * PULSE GRID - FIXED VIEWPORT EDITION
 */

const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    
    COLS: 10,
    ROWS: 10,
    GAP: 2,
    
    // Dimensions
    width: 0,
    height: 0,
    pixelRatio: 1,
    blockSize: 0,
    boardX: 0,
    boardY: 0,
    
    // Game State
    grid: [],
    hand: [],
    score: 0,
    highScore: localStorage.getItem('pulseHigh') || 0,
    moves: 0,
    gameState: 'START',
    
    // Pulse
    pulseMode: 'NORMAL',
    pulseTimer: 0,
    lockedCells: [],
    fallingPieces: [],

    // Inputs
    draggingShape: null,
    dragOffsetX: 0,
    dragOffsetY: 0,
    touchOffsetY: 120, // Float Offset

    colors: ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#1abc9c'],
    shapesDB: [
        [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
        [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]],
        [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]]
    ],

    init() {
        this.ctx = this.canvas.getContext('2d');
        document.getElementById('highscore-val').innerText = this.highScore;
        
        // Input Binding
        const start = (e) => this.handleStart(e);
        const move = (e) => this.handleMove(e);
        const end = (e) => this.handleEnd(e);

        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end, {passive: false});

        // Start Button Logic
        const btn = document.getElementById('start-btn');
        const trigger = (e) => {
            e.preventDefault();
            this.attemptFullscreen(); // Try the API
            document.getElementById('start-screen').classList.add('hidden');
            this.resize();
            this.reset();
        };
        btn.addEventListener('click', trigger);
        btn.addEventListener('touchstart', trigger);

        // Resize loop
        window.addEventListener('resize', () => this.resize());
        this.resize();

        // Game Loop
        requestAnimationFrame(() => this.loop());
    },

    // The method from "Block Blast" to attempt fullscreen API
    attemptFullscreen() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => console.log(err));
        } else if (elem.webkitRequestFullscreen) { 
            elem.webkitRequestFullscreen();
        }
    },

    resize() {
        // 1. Get the Wrapper dimensions (not window directly, but the flex container)
        const wrapper = document.getElementById('canvas-wrapper');
        const rect = wrapper.getBoundingClientRect();
        
        // 2. High DPI handling
        this.pixelRatio = window.devicePixelRatio || 1;
        
        // 3. Set Canvas Dimensions
        // We use slightly less than full width/height for padding
        const w = rect.width * 0.96;
        const h = rect.height * 0.98;

        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.canvas.width = w * this.pixelRatio;
        this.canvas.height = h * this.pixelRatio;
        this.ctx.scale(this.pixelRatio, this.pixelRatio);

        this.width = w;
        this.height = h;

        // 4. Calculate Block Size
        // We need space for Grid (10) + Hand (approx 4 blocks high)
        const sizeW = (this.width - (this.GAP * (this.COLS + 1))) / this.COLS;
        const sizeH = (this.height - (this.GAP * (this.ROWS + 1))) / (this.ROWS + 5); 
        this.blockSize = Math.floor(Math.min(sizeW, sizeH));

        // 5. Centering
        const gridPixelW = (this.blockSize * this.COLS) + (this.GAP * (this.COLS - 1));
        this.boardX = (this.width - gridPixelW) / 2;
        this.boardY = 10; // Padding top

        // Hand Position (Below Grid)
        this.handY = this.boardY + (this.blockSize * this.ROWS) + (this.GAP * this.ROWS) + 20;
        
        // Update Touch Offset based on block size
        this.touchOffsetY = this.blockSize * 2.5;

        if(this.hand.length > 0) this.repositionHand();
    },

    reset() {
        this.grid = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(null));
        this.score = 0;
        this.moves = 0;
        this.pulseMode = 'NORMAL';
        this.pulseTimer = 0;
        this.lockedCells = [];
        this.gameState = 'IDLE';
        this.fallingPieces = [];
        this.updateUI();
        document.getElementById('game-over').classList.add('hidden');
        this.spawnHand();
    },

    spawnHand() {
        this.hand = [];
        for(let i=0; i<3; i++) {
            const t = this.shapesDB[Math.floor(Math.random()*this.shapesDB.length)];
            const c = this.colors[Math.floor(Math.random()*this.colors.length)];
            this.hand.push({ 
                matrix: t, color: c, 
                x: 0, y: 0, homeX: 0, homeY: 0, isDragging: false 
            });
        }
        this.repositionHand();
        this.checkGameOver();
    },

    repositionHand() {
        const slotW = this.width / 3;
        this.hand.forEach((s, i) => {
            if(!s.isDragging) {
                const sw = s.matrix[0].length * this.blockSize;
                const sh = s.matrix.length * this.blockSize;
                s.homeX = (i * slotW) + (slotW/2) - (sw/2);
                s.homeY = this.handY + this.blockSize; // Centered vertically in hand area
                s.x = s.homeX;
                s.y = s.homeY;
            }
        });
    },

    // --- LOGIC ---
    triggerPulse() {
        const m = ['GRAVITY', 'LOCKED', 'ECHO'];
        if(Math.random()<0.3) { this.pulseMode='NORMAL'; this.pulseTimer=0; }
        else {
            this.pulseMode = m[Math.floor(Math.random()*m.length)];
            this.pulseTimer = Math.floor(Math.random()*3)+3;
        }
        if(this.pulseMode==='LOCKED') this.spawnLocks(); else this.lockedCells=[];
        this.updateUI();
    },

    processTurn() {
        this.moves++;
        if(this.pulseMode!=='NORMAL') {
            this.pulseTimer--;
            if(this.pulseTimer<=0) { this.pulseMode='NORMAL'; this.lockedCells=[]; }
        } else if(this.moves%5===0) this.triggerPulse();
        this.updateUI();
    },

    spawnLocks() {
        let n=0, k=0;
        while(n<3 && k<50) {
            let r=Math.floor(Math.random()*this.ROWS), c=Math.floor(Math.random()*this.COLS);
            if(!this.grid[r][c] && !this.isLocked(r,c)) { this.lockedCells.push({r,c}); n++; }
            k++;
        }
    },

    isLocked(r, c) { return this.lockedCells.some(l => l.r===r && l.c===c); },

    checkLines() {
        let rc=[], cc=[];
        for(let r=0; r<this.ROWS; r++) if(this.grid[r].every(v=>v)) rc.push(r);
        for(let c=0; c<this.COLS; c++) {
            let f=true; for(let r=0; r<this.ROWS; r++) if(!this.grid[r][c]) f=false;
            if(f) cc.push(c);
        }

        if(this.pulseMode==='ECHO' && (rc.length>0||cc.length>0)) {
            let er=[];
            rc.forEach(r => { if(r+1<this.ROWS) er.push(r+1); if(r-1>=0) er.push(r-1); });
            rc=[...new Set([...rc, ...er])];
        }

        rc.forEach(r => { for(let c=0; c<this.COLS; c++) this.grid[r][c]=null; });
        cc.forEach(c => { for(let r=0; r<this.ROWS; r++) this.grid[r][c]=null; });

        let tot = (rc.length*this.COLS) + (cc.length*this.ROWS);
        if(tot>0) {
            let pts = tot*10; if(rc.length>1||cc.length>1) pts*=2;
            this.addScore(pts);
        }

        if(this.pulseMode==='GRAVITY') this.startGravity();
        else this.checkGameOver();
    },

    startGravity() {
        this.fallingPieces = [];
        let m=false;
        for(let c=0; c<this.COLS; c++) {
            let w = this.ROWS-1;
            for(let r=this.ROWS-1; r>=0; r--) {
                if(this.isLocked(r,c)) { w=r-1; continue; }
                if(this.grid[r][c]) {
                    if(r!==w) {
                        m=true;
                        this.fallingPieces.push({
                            color: this.grid[r][c], c:c,
                            x: this.boardX+c*(this.blockSize+this.GAP),
                            y: this.boardY+r*(this.blockSize+this.GAP),
                            ty: this.boardY+w*(this.blockSize+this.GAP),
                            tr: w
                        });
                        this.grid[r][c]=null;
                    }
                    w--;
                }
            }
        }
        if(m) this.gameState='ANIMATING'; else this.checkGameOver();
    },

    updateAnim() {
        if(this.gameState!=='ANIMATING') return;
        let act=false; const spd=this.blockSize; 
        this.fallingPieces.forEach(p => {
            if(p.y < p.ty) { p.y+=spd; act=true; if(p.y>=p.ty) p.y=p.ty; }
        });
        if(!act) {
            this.fallingPieces.forEach(p => this.grid[p.tr][p.c]=p.color);
            this.fallingPieces=[]; this.gameState='IDLE'; this.checkGameOver();
        }
    },

    canPlace(s, gr, gc) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    let tr=gr+r, tc=gc+c;
                    if(tr<0||tr>=this.ROWS||tc<0||tc>=this.COLS) return false;
                    if(this.grid[tr][tc] || this.isLocked(tr,tc)) return false;
                }
            }
        }
        return true;
    },

    placeShape(s, gr, gc) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) this.grid[gr+r][gc+c]=s.color;
            }
        }
        this.addScore(s.matrix.flat().filter(x=>x).length);
        this.hand = this.hand.filter(h => h!==s);
        this.processTurn();
        this.checkLines();
        if(this.hand.length===0) this.spawnHand();
    },

    checkGameOver() {
        if(this.gameState==='ANIMATING'||this.hand.length===0) return;
        let pos=false;
        for(let s of this.hand) {
            for(let r=0; r<this.ROWS; r++) {
                for(let c=0; c<this.COLS; c++) if(this.canPlace(s,r,c)) { pos=true; break; }
                if(pos) break;
            }
            if(pos) break;
        }
        if(!pos) {
            this.gameState='GAMEOVER';
            document.getElementById('final-score').innerText=this.score;
            if(this.score>this.highScore) {
                this.highScore=this.score;
                localStorage.setItem('pulseHigh', this.highScore);
            }
            document.getElementById('game-over').classList.remove('hidden');
        }
    },

    addScore(p) { this.score+=p; this.updateUI(); },
    
    updateUI() {
        document.getElementById('score-val').innerText=this.score;
        document.getElementById('highscore-val').innerText=this.highScore;
        const b = document.getElementById('pulse-bar');
        b.className = '';
        if(this.pulseMode==='NORMAL') { b.classList.add('pulse-normal'); b.innerText="STATUS: NORMAL"; }
        else {
            b.classList.add(`pulse-${this.pulseMode.toLowerCase()}`);
            b.innerText = `${this.pulseMode} (${this.pulseTimer})`;
        }
    },

    // --- INPUT ---
    getPointer(e) {
        const r = this.canvas.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: cx - r.left, y: cy - r.top };
    },

    handleStart(e) {
        if(this.gameState!=='IDLE') return;
        const p = this.getPointer(e);
        const pad = 30;
        for(let s of this.hand) {
            const w = s.matrix[0].length * this.blockSize;
            const h = s.matrix.length * this.blockSize;
            if(p.x >= s.x-pad && p.x <= s.x+w+pad && p.y >= s.y-pad && p.y <= s.y+h+pad) {
                this.draggingShape = s;
                s.isDragging = true;
                this.dragOffsetX = p.x - s.x;
                this.dragOffsetY = p.y - s.y;
                break;
            }
        }
    },

    handleMove(e) {
        if(!this.draggingShape) return;
        e.preventDefault();
        const p = this.getPointer(e);
        this.draggingShape.x = p.x - this.dragOffsetX;
        this.draggingShape.y = p.y - this.dragOffsetY - this.touchOffsetY;
    },

    handleEnd(e) {
        if(!this.draggingShape) return;
        const s = this.draggingShape;
        const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
        const cy = s.y + (s.matrix.length * this.blockSize)/2;
        const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
        const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));

        if(this.canPlace(s, gr, gc)) this.placeShape(s, gr, gc);
        else { s.x = s.homeX; s.y = s.homeY; }
        
        s.isDragging = false;
        this.draggingShape = null;
    },

    // --- RENDER ---
    loop() {
        this.updateAnim();
        this.draw();
        requestAnimationFrame(() => this.loop());
    },

    draw() {
        this.ctx.clearRect(0,0,this.width,this.height);

        // Grid
        for(let r=0; r<this.ROWS; r++) {
            for(let c=0; c<this.COLS; c++) {
                const x = this.boardX + c*(this.blockSize+this.GAP);
                const y = this.boardY + r*(this.blockSize+this.GAP);
                
                // BG
                this.ctx.fillStyle = '#2a2a30';
                this.roundRect(x,y,this.blockSize,this.blockSize,4);
                this.ctx.fill();

                // Lock
                if(this.isLocked(r,c)) {
                    this.ctx.fillStyle='#111'; this.ctx.fill();
                    this.ctx.strokeStyle='#c0392b'; this.ctx.lineWidth=2;
                    this.ctx.strokeRect(x+4,y+4,this.blockSize-8,this.blockSize-8);
                }

                if(this.grid[r][c]) this.drawBlock(x,y,this.grid[r][c]);
            }
        }

        // Falling
        this.fallingPieces.forEach(p => this.drawBlock(p.x, p.y, p.color));

        // Divider
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(0, this.handY-10, this.width, 2);

        // Hand
        this.hand.forEach(s => {
            if(s.isDragging) {
                // Ghost
                const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
                const cy = s.y + (s.matrix.length * this.blockSize)/2;
                const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
                const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));
                if(this.canPlace(s, gr, gc)) {
                    this.ctx.globalAlpha = 0.3;
                    this.drawShapeAt(s, this.boardX+gc*(this.blockSize+this.GAP), this.boardY+gr*(this.blockSize+this.GAP), '#fff');
                    this.ctx.globalAlpha = 1.0;
                }
            }
            this.drawShape(s);
        });

        // Border Effect
        if(this.pulseMode!=='NORMAL') {
            this.ctx.strokeStyle = this.pulseMode==='GRAVITY'?'#f39c12':this.pulseMode==='LOCKED'?'#e74c3c':'#9b59b6';
            this.ctx.lineWidth = 4;
            this.ctx.strokeRect(this.boardX-3, this.boardY-3, (this.blockSize+this.GAP)*this.COLS+2, (this.blockSize+this.GAP)*this.ROWS+2);
        }
    },

    drawBlock(x, y, c) {
        this.ctx.fillStyle = c;
        this.roundRect(x,y,this.blockSize,this.blockSize,4);
        this.ctx.fill();
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.fillRect(x+2,y+2,this.blockSize-4,this.blockSize*0.3);
    },

    drawShape(s) {
        const size = s.isDragging ? this.blockSize : this.blockSize*0.85;
        const g = s.isDragging ? this.GAP : 2;
        if(s.isDragging) {
            this.ctx.shadowColor='rgba(0,0,0,0.5)'; this.ctx.shadowBlur=15; this.ctx.shadowOffsetY=15;
        }
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    this.ctx.fillStyle = s.color;
                    this.roundRect(s.x + c*(size+g), s.y + r*(size+g), size, size, 4);
                    this.ctx.fill();
                }
            }
        }
        this.ctx.shadowColor='transparent'; this.ctx.shadowBlur=0; this.ctx.shadowOffsetY=0;
    },

    drawShapeAt(s, x, y, c) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    this.ctx.fillStyle = c;
                    this.roundRect(x + c*(this.blockSize+this.GAP), y + r*(this.blockSize+this.GAP), this.blockSize, this.blockSize, 4);
                    this.ctx.fill();
                }
            }
        }
    },

    roundRect(x, y, w, h, r) {
        this.ctx.beginPath();
        this.ctx.moveTo(x+r, y); this.ctx.lineTo(x+w-r, y); this.ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        this.ctx.lineTo(x+w, y+h-r); this.ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        this.ctx.lineTo(x+r, y+h); this.ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        this.ctx.lineTo(x, y+r); this.ctx.quadraticCurveTo(x, y, x+r, y);
        this.ctx.closePath();
    }
};

window.onload = () => {
    // FORCE HEIGHT LOGIC
    const setH = () => document.body.style.height = window.innerHeight + "px";
    window.addEventListener("resize", setH);
    setH();
    Game.init();
};
</script>
</body>
</html>
