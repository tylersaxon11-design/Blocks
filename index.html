<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- Mobile Fullscreen Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#121212">

    <title>Pulse Grid</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-bg: #1e1e24;
            --highlight: #00fff2;
            --text-color: #ffffff;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            /* Use dynamic viewport height to account for mobile address bars */
            height: 100dvh; 
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden; /* Prevent scrolling completely */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none; /* Disable native gestures like zoom/scroll */
            -webkit-user-select: none; /* Disable text selection on iOS */
            user-select: none;
        }

        #ui-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            z-index: 2;
            flex-shrink: 0; /* Don't shrink the UI */
        }

        .stat-box {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 15px;
            border-radius: 12px;
            min-width: 80px;
        }

        .label {
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #aaa;
            letter-spacing: 1px;
        }

        .value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }

        #pulse-indicator {
            margin-top: 5px;
            padding: 10px 20px;
            background: #333;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            border: 2px solid #555;
            transition: all 0.3s ease;
            width: 90%;
            max-width: 500px;
            z-index: 2;
            flex-shrink: 0;
        }

        canvas {
            background-color: var(--grid-bg);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            margin: 10px 0;
            cursor: pointer;
            z-index: 1;
            touch-action: none;
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100dvh;
            background: rgba(18, 18, 18, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
            text-align: center;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: var(--highlight);
            text-shadow: 0 0 20px var(--highlight);
        }

        p {
            font-size: 1.2rem;
            color: #ddd;
            margin: 10px 20px;
            line-height: 1.5;
            max-width: 400px;
        }

        button {
            padding: 20px 40px;
            font-size: 1.4rem;
            background: var(--highlight);
            border: none;
            border-radius: 12px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 242, 0.4);
            -webkit-tap-highlight-color: transparent;
        }

        button:active {
            transform: scale(0.95);
        }

        /* Status Colors */
        .pulse-normal { border-color: #555; color: #fff; }
        .pulse-gravity { border-color: #f39c12; color: #f39c12; background: #2e2005; }
        .pulse-locked { border-color: #e74c3c; color: #e74c3c; background: #2c0b0b; }
        .pulse-echo { border-color: #9b59b6; color: #9b59b6; background: #1a0524; }
        
    </style>
</head>
<body>

    <!-- UI Elements -->
    <div id="ui-container">
        <div class="stat-box">
            <div class="label">Score</div>
            <div class="value" id="score-val">0</div>
        </div>
        <div class="stat-box">
            <div class="label">Best</div>
            <div class="value" id="highscore-val">0</div>
        </div>
    </div>

    <div id="pulse-indicator" class="pulse-normal">STATUS: NORMAL</div>
    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay">
        <h1>PULSE GRID</h1>
        <p>Drag blocks to fill rows.</p>
        <p style="font-size: 1rem; color: #888; margin-top: 5px;">Blocks float above your finger for easy placement.</p>
        <button id="start-btn">TAP TO START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over" class="overlay hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 0 15px #e74c3c;">GRID LOCKED</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">PLAY AGAIN</button>
    </div>

<script>
/**
 * PULSE GRID - MOBILE FULLSCREEN EDITION
 */

// --- Configuration ---
const COLS = 10;
const ROWS = 10;
const GAP = 2; 

// Base size used for logic, but rendering is scaled dynamically
let BASE_BLOCK_SIZE = 40; 
let SCALE = 1; 
let TOUCH_OFFSET_Y = 120; // How far up the piece floats

const COLORS = [
    '#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#1abc9c'
];

// --- Game State ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-val');
const highScoreEl = document.getElementById('highscore-val');
const pulseEl = document.getElementById('pulse-indicator');
const gameOverScreen = document.getElementById('game-over');
const startScreen = document.getElementById('start-screen');
const startBtn = document.getElementById('start-btn');
const finalScoreEl = document.getElementById('final-score');

let grid = []; 
let hand = []; 
let score = 0;
let highScore = localStorage.getItem('pulseHigh') || 0;
let moves = 0;

// Dragging State
let draggingShape = null;
let dragX = 0;
let dragY = 0;

let gameState = 'START'; 
let fallingPieces = []; 
let pulseMode = 'NORMAL'; 
let pulseTimer = 0; 
let lockedCells = []; 

// Define Shapes
const SHAPES = [
    [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
    [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]],
    [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]]
];

// --- Initialization & Resizing ---

function resize() {
    // Get actual viewport size (ignoring address bar if possible via innerHeight)
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight;
    
    // Reserve vertical space for UI (Score + Status + Bottom Buffer)
    // We calculate this dynamically to be safe
    const uiHeight = 180; 
    
    // The available height for the canvas
    const availableHeight = maxHeight - uiHeight;

    // Dimensions of the logical grid including the "Hand" area at bottom
    // Grid = 10 blocks + Hand Area (~4 blocks height equivalent)
    const logicalGridWidth = (BASE_BLOCK_SIZE + GAP) * COLS + GAP;
    const logicalGridHeight = (BASE_BLOCK_SIZE + GAP) * ROWS + GAP + 140; // + Hand area

    // Determine scale factor
    const scaleW = (maxWidth * 0.96) / logicalGridWidth; // 96% width for margins
    const scaleH = (availableHeight * 0.96) / logicalGridHeight;
    
    SCALE = Math.min(scaleW, scaleH);

    // Limit max scale
    if (SCALE > 1.6) SCALE = 1.6;

    canvas.width = logicalGridWidth * SCALE;
    canvas.height = logicalGridHeight * SCALE;
    
    // Adjust touch offset based on scale
    TOUCH_OFFSET_Y = 110 * SCALE;
}

// Mobile Fullscreen Logic
function attemptFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) {
        elem.requestFullscreen().catch(err => console.log("Fullscreen blocked or not supported", err));
    } else if (elem.webkitRequestFullscreen) { /* Safari */
        elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { /* IE11 */
        elem.msRequestFullscreen();
    }
}

// Handling the Start Button
const startGame = (e) => {
    e.preventDefault(); // Prevent phantom clicks
    attemptFullscreen();
    
    // Add a small delay to allow fullscreen transition to happen before resizing
    setTimeout(() => {
        resize();
        startScreen.classList.add('hidden');
        init();
    }, 100);
};

startBtn.addEventListener('click', startGame);
startBtn.addEventListener('touchstart', startGame);

window.addEventListener('resize', () => {
    // Debounce resize
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(() => {
        resize();
        draw();
    }, 50);
});

function init() {
    highScoreEl.innerText = highScore;
    resize();
    resetGame();
    
    // Mouse Events
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    
    // Touch Events (passive: false is crucial to prevent scrolling)
    canvas.addEventListener('touchstart', handleTouch, { passive: false });
    window.addEventListener('touchmove', handleTouch, { passive: false });
    window.addEventListener('touchend', handleTouch, { passive: false });

    requestAnimationFrame(loop);
}

function resetGame() {
    grid = Array(ROWS).fill().map(() => Array(COLS).fill(null));
    score = 0;
    moves = 0;
    pulseMode = 'NORMAL';
    pulseTimer = 0;
    lockedCells = [];
    gameState = 'IDLE';
    fallingPieces = [];
    updateUI();
    gameOverScreen.classList.add('hidden');
    
    spawnHand();
}

function spawnHand() {
    hand = [];
    for(let i=0; i<3; i++) {
        hand.push(createRandomShape(i));
    }
    checkGameOver();
}

function createRandomShape(slotIndex) {
    const template = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
    
    const slotWidth = ((BASE_BLOCK_SIZE + GAP) * COLS) / 3;
    const centerX = (slotIndex * slotWidth) + (slotWidth / 2);
    // Position hand slightly lower relative to grid end
    const centerY = ((BASE_BLOCK_SIZE + GAP) * ROWS) + 70;

    const shapeW = template[0].length * BASE_BLOCK_SIZE;
    const shapeH = template.length * BASE_BLOCK_SIZE;

    return {
        matrix: template,
        color: color,
        x: centerX - shapeW/2,
        y: centerY - shapeH/2,
        homeX: centerX - shapeW/2,
        homeY: centerY - shapeH/2,
        isDragging: false
    };
}

// --- Logic ---

function triggerPulse() {
    const modes = ['GRAVITY', 'LOCKED', 'ECHO'];
    if (Math.random() < 0.3) {
        pulseMode = 'NORMAL';
        pulseTimer = 0;
    } else {
        pulseMode = modes[Math.floor(Math.random() * modes.length)];
        pulseTimer = Math.floor(Math.random() * 3) + 3;
    }

    if (pulseMode === 'LOCKED') {
        spawnLockedCells();
    } else {
        lockedCells = [];
    }
    updateUI();
}

function processTurn() {
    moves++;
    if (pulseMode !== 'NORMAL') {
        pulseTimer--;
        if (pulseTimer <= 0) {
            pulseMode = 'NORMAL';
            lockedCells = [];
        }
    } else if (moves % 5 === 0) {
        triggerPulse();
    }
    updateUI();
}

function spawnLockedCells() {
    let locksPlaced = 0;
    let attempts = 0;
    while(locksPlaced < 3 && attempts < 50) {
        let r = Math.floor(Math.random() * ROWS);
        let c = Math.floor(Math.random() * COLS);
        if (!grid[r][c] && !isLocked(r,c)) {
            lockedCells.push({r, c});
            locksPlaced++;
        }
        attempts++;
    }
}

function isLocked(r, c) {
    return lockedCells.some(cell => cell.r === r && cell.c === c);
}

function checkLines() {
    let rowsToClear = [];
    let colsToClear = [];

    for (let r = 0; r < ROWS; r++) {
        if (grid[r].every(cell => cell !== null)) rowsToClear.push(r);
    }
    for (let c = 0; c < COLS; c++) {
        let colFilled = true;
        for (let r = 0; r < ROWS; r++) {
            if (grid[r][c] === null) { colFilled = false; break; }
        }
        if (colFilled) colsToClear.push(c);
    }

    if (pulseMode === 'ECHO' && (rowsToClear.length > 0 || colsToClear.length > 0)) {
        let echoRows = [];
        rowsToClear.forEach(r => {
            if (r + 1 < ROWS && !rowsToClear.includes(r+1)) echoRows.push(r+1);
            if (r - 1 >= 0 && !rowsToClear.includes(r-1)) echoRows.push(r-1);
        });
        rowsToClear = [...rowsToClear, ...echoRows];
    }

    rowsToClear.forEach(r => { for(let c=0; c<COLS; c++) grid[r][c] = null; });
    colsToClear.forEach(c => { for(let r=0; r<ROWS; r++) grid[r][c] = null; });

    let totalCells = (rowsToClear.length * COLS) + (colsToClear.length * ROWS);
    if (totalCells > 0) {
        let points = totalCells * 10;
        if (rowsToClear.length > 1 || colsToClear.length > 1) points *= 2; 
        addScore(points);
    }

    if (pulseMode === 'GRAVITY') {
        prepareGravityAnimation();
    } else {
        checkGameOver();
    }
}

function prepareGravityAnimation() {
    fallingPieces = [];
    let hasMovement = false;

    for (let c = 0; c < COLS; c++) {
        let writeRow = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
            if (isLocked(r, c)) {
                writeRow = r - 1;
                continue;
            }
            if (grid[r][c] !== null) {
                if (r !== writeRow) {
                    hasMovement = true;
                    fallingPieces.push({
                        color: grid[r][c],
                        c: c,
                        x: c * (BASE_BLOCK_SIZE + GAP) + GAP,
                        y: r * (BASE_BLOCK_SIZE + GAP) + GAP, 
                        targetY: writeRow * (BASE_BLOCK_SIZE + GAP) + GAP, 
                        targetR: writeRow 
                    });
                    grid[r][c] = null; 
                }
                writeRow--; 
            }
        }
    }

    if (hasMovement) {
        gameState = 'ANIMATING';
    } else {
        checkGameOver();
    }
}

function updateAnimation() {
    if (gameState !== 'ANIMATING') return;

    let active = false;
    const speed = 25; 

    fallingPieces.forEach(p => {
        if (p.y < p.targetY) {
            p.y += speed;
            active = true;
            if (p.y >= p.targetY) p.y = p.targetY;
        }
    });

    if (!active) {
        fallingPieces.forEach(p => {
            grid[p.targetR][p.c] = p.color;
        });
        fallingPieces = [];
        gameState = 'IDLE';
        checkGameOver();
    }
}

function canPlace(shape, gridX, gridY) {
    for (let r = 0; r < shape.matrix.length; r++) {
        for (let c = 0; c < shape.matrix[r].length; c++) {
            if (shape.matrix[r][c] === 1) {
                let targetR = gridY + r;
                let targetC = gridX + c;
                if (targetR < 0 || targetR >= ROWS || targetC < 0 || targetC >= COLS) return false;
                if (grid[targetR][targetC] !== null) return false;
                if (isLocked(targetR, targetC)) return false;
            }
        }
    }
    return true;
}

function placeShape(shape, gridX, gridY) {
    for (let r = 0; r < shape.matrix.length; r++) {
        for (let c = 0; c < shape.matrix[r].length; c++) {
            if (shape.matrix[r][c] === 1) {
                grid[gridY + r][gridX + c] = shape.color;
            }
        }
    }
    
    addScore(shape.matrix.flat().filter(x=>x===1).length); 
    hand = hand.filter(s => s !== shape);
    
    processTurn();
    checkLines();
    
    if (hand.length === 0) spawnHand();
}

function checkGameOver() {
    if (gameState === 'ANIMATING') return; 

    let canMove = false;
    if(hand.length === 0) return;

    for (let s of hand) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (canPlace(s, c, r)) {
                    canMove = true;
                    break;
                }
            }
            if (canMove) break;
        }
        if (canMove) break;
    }

    if (!canMove) {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('pulseHigh', highScore);
        }
        gameOverScreen.classList.remove('hidden');
    }
}

function addScore(pts) {
    score += pts;
    updateUI();
}

function updateUI() {
    scoreEl.innerText = score;
    highScoreEl.innerText = highScore;

    pulseEl.className = ''; 
    if (pulseMode === 'NORMAL') {
        pulseEl.classList.add('pulse-normal');
        pulseEl.innerText = `STATUS: NORMAL`;
    } else {
        pulseEl.classList.add(`pulse-${pulseMode.toLowerCase()}`);
        let desc = "";
        if (pulseMode === 'GRAVITY') desc = "GRAVITY SHIFT";
        if (pulseMode === 'LOCKED') desc = "GRID LOCKED";
        if (pulseMode === 'ECHO') desc = "ECHO BLAST";
        pulseEl.innerText = `${desc} (${pulseTimer})`;
    }
}

// --- Input Handling ---

function getPointerPos(e) {
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const rect = canvas.getBoundingClientRect();
    
    return { 
        x: (clientX - rect.left) / SCALE, 
        y: (clientY - rect.top) / SCALE 
    };
}

function onMouseDown(e) {
    if (gameState !== 'IDLE') return; 
    const pos = getPointerPos(e);
    
    for (let shape of hand) {
        const sW = shape.matrix[0].length * BASE_BLOCK_SIZE;
        const sH = shape.matrix.length * BASE_BLOCK_SIZE;
        const padding = 30; // Extra padding for easy grabbing

        if (pos.x > shape.x - padding && pos.x < shape.x + sW + padding &&
            pos.y > shape.y - padding && pos.y < shape.y + sH + padding) {
            
            draggingShape = shape;
            shape.isDragging = true;
            dragX = pos.x - shape.x;
            dragY = pos.y - shape.y;
            break;
        }
    }
}

function onMouseMove(e) {
    if (!draggingShape) return;
    const pos = getPointerPos(e);
    
    draggingShape.x = pos.x - dragX;
    // Apply offset so finger doesn't cover block
    draggingShape.y = pos.y - dragY - (TOUCH_OFFSET_Y / SCALE);
}

function onMouseUp(e) {
    if (!draggingShape) return;
    
    // Calculate Grid Position based on Top-Left
    const preciseGridX = Math.round(draggingShape.x / (BASE_BLOCK_SIZE + GAP));
    const preciseGridY = Math.round(draggingShape.y / (BASE_BLOCK_SIZE + GAP));
    
    if (canPlace(draggingShape, preciseGridX, preciseGridY)) {
        placeShape(draggingShape, preciseGridX, preciseGridY);
    } else {
        // Return to hand
        draggingShape.x = draggingShape.homeX;
        draggingShape.y = draggingShape.homeY;
    }

    draggingShape.isDragging = false;
    draggingShape = null;
}

function handleTouch(e) {
    // Prevent default browser scrolling/zooming
    if(e.type === 'touchmove') e.preventDefault();
    
    if (e.type === 'touchstart') onMouseDown(e);
    if (e.type === 'touchmove') onMouseMove(e);
    if (e.type === 'touchend') onMouseUp(e);
}

// --- Rendering ---

function draw() {
    updateAnimation(); 

    ctx.save();
    ctx.scale(SCALE, SCALE); 
    
    ctx.clearRect(0, 0, canvas.width/SCALE, canvas.height/SCALE);

    // Grid
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let x = c * (BASE_BLOCK_SIZE + GAP) + GAP;
            let y = r * (BASE_BLOCK_SIZE + GAP) + GAP;

            ctx.fillStyle = '#2a2a30';
            ctx.fillRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);

            if (isLocked(r, c)) {
                ctx.fillStyle = '#222';
                ctx.fillRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x + 5, y + 5);
                ctx.lineTo(x + BASE_BLOCK_SIZE - 5, y + BASE_BLOCK_SIZE - 5);
                ctx.moveTo(x + BASE_BLOCK_SIZE - 5, y + 5);
                ctx.lineTo(x + 5, y + BASE_BLOCK_SIZE - 5);
                ctx.stroke();
            }

            if (grid[r][c]) {
                ctx.fillStyle = grid[r][c];
                ctx.fillRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(x, y, BASE_BLOCK_SIZE, 4);
                ctx.fillRect(x, y, 4, BASE_BLOCK_SIZE);
            }
        }
    }

    // Animating Pieces
    fallingPieces.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(p.x, p.y, BASE_BLOCK_SIZE, 4);
        ctx.fillRect(p.x, p.y, 4, BASE_BLOCK_SIZE);
    });

    // Border
    if (pulseMode !== 'NORMAL') {
        ctx.strokeStyle = pulseMode === 'GRAVITY' ? '#f39c12' : 
                          pulseMode === 'LOCKED' ? '#e74c3c' : '#9b59b6';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, COLS * (BASE_BLOCK_SIZE+GAP) + GAP, ROWS * (BASE_BLOCK_SIZE+GAP) + GAP);
    }

    // Hand Divider
    ctx.fillStyle = '#444';
    ctx.fillRect(0, ROWS * (BASE_BLOCK_SIZE+GAP) + GAP + 10, (BASE_BLOCK_SIZE * COLS) + 30, 2);

    // Shapes
    for (let shape of hand) {
        drawShape(shape);
    }

    // Ghost Preview
    if (draggingShape && gameState === 'IDLE') {
        const preciseGridX = Math.round(draggingShape.x / (BASE_BLOCK_SIZE + GAP));
        const preciseGridY = Math.round(draggingShape.y / (BASE_BLOCK_SIZE + GAP));
        
        if (canPlace(draggingShape, preciseGridX, preciseGridY)) {
            ctx.globalAlpha = 0.5;
            drawShapeAtGrid(draggingShape, preciseGridX, preciseGridY, null, true);
            ctx.globalAlpha = 1.0;
        }
    }

    ctx.restore();
    requestAnimationFrame(loop);
}

function drawShape(shape) {
    if (shape.isDragging) {
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 20;
    }
    for (let r = 0; r < shape.matrix.length; r++) {
        for (let c = 0; c < shape.matrix[r].length; c++) {
            if (shape.matrix[r][c] === 1) {
                let x = shape.x + c * BASE_BLOCK_SIZE;
                let y = shape.y + r * BASE_BLOCK_SIZE;
                let size = BASE_BLOCK_SIZE - 2; 

                ctx.fillStyle = shape.color;
                ctx.fillRect(x, y, size, size);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x,y,size,size);
            }
        }
    }
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
}

function drawShapeAtGrid(shape, gridX, gridY, overrideColor, isGhost) {
    for (let r = 0; r < shape.matrix.length; r++) {
        for (let c = 0; c < shape.matrix[r].length; c++) {
            if (shape.matrix[r][c] === 1) {
                let x = (gridX + c) * (BASE_BLOCK_SIZE + GAP) + GAP;
                let y = (gridY + r) * (BASE_BLOCK_SIZE + GAP) + GAP;
                
                if (isGhost) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
                } else {
                    ctx.fillStyle = overrideColor || shape.color;
                    ctx.fillRect(x, y, BASE_BLOCK_SIZE, BASE_BLOCK_SIZE);
                }
            }
        }
    }
}

function loop() {
    draw();
}

</script>
</body>
</html>
