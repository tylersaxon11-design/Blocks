<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pulse Grid</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-bg: #1e1e24;
            --highlight: #00fff2;
            --text-color: #ffffff;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* EXACT CSS METHOD FROM REFERENCE CODE */
        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: var(--font-main);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Will be overridden by JS */
            color: white;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header-container {
            width: 96%;
            margin-top: 10px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 80px;
        }
        .label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; }
        .value { font-size: 1.2rem; font-weight: bold; }

        #pulse-indicator {
            width: 96%;
            padding: 8px 0;
            margin-bottom: 5px;
            background: #222;
            border-radius: 15px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid #444;
            text-transform: uppercase;
        }

        /* Canvas Wrapper: Grows to fill space */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding-bottom: 10px;
        }

        canvas {
            border-radius: 8px;
            /* Canvas size is handled by JS logic */
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* MODALS */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 18, 18, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        h1 { font-size: 3rem; margin: 0; color: var(--highlight); text-shadow: 0 0 20px var(--highlight); }
        p { color: #ccc; margin: 15px 0; max-width: 300px; text-align: center; }

        button {
            background: var(--highlight);
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 30px;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(0,255,242,0.4);
            cursor: pointer;
        }
        button:active { transform: scale(0.95); }

        /* Status Colors */
        .pulse-normal { border-color: #555; color: #fff; }
        .pulse-gravity { border-color: #f39c12; color: #f39c12; background: rgba(243, 156, 18, 0.1); }
        .pulse-locked { border-color: #e74c3c; color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .pulse-echo { border-color: #9b59b6; color: #9b59b6; background: rgba(155, 89, 182, 0.1); }

    </style>
</head>
<body>

<div id="game-container">
    <!-- Header -->
    <div class="header-container">
        <div class="stat-box">
            <div class="label">Score</div>
            <div class="value" id="score-val">0</div>
        </div>
        <div class="stat-box">
            <div class="label">Best</div>
            <div class="value" id="highscore-val">0</div>
        </div>
    </div>

    <div id="pulse-indicator" class="pulse-normal">STATUS: NORMAL</div>

    <!-- Canvas Container -->
    <div class="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="modal-overlay">
        <h1>PULSE GRID</h1>
        <p>Drag blocks to fill rows.<br>Blocks float above your finger.</p>
        <button onclick="startGame()">TAP TO PLAY</button>
    </div>

    <!-- Game Over -->
    <div id="game-over" class="modal-overlay hidden">
        <h1 style="color: #e74c3c;">GRID LOCKED</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="GameApp.reset()">PLAY AGAIN</button>
    </div>
</div>

<script>
/**
 * PULSE GRID - RESTORED & OPTIMIZED
 * Uses the exact "Block Blast" Reference Layout Method
 */

// Fullscreen Helper from Reference Code
function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log("Fullscreen ignored (likely iOS)", err);
        });
    }
}

function startGame() {
    toggleFullScreen();
    document.getElementById('start-screen').classList.add('hidden');
    GameApp.init();
}

class PulseGrid {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.wrapper = document.querySelector('.canvas-wrapper');

        // Config
        this.COLS = 10;
        this.ROWS = 10;
        this.GAP = 2;
        
        // State
        this.grid = [];
        this.hand = [];
        this.score = 0;
        this.highScore = localStorage.getItem('pulseHigh') || 0;
        this.moves = 0;
        this.gameState = 'IDLE'; 

        // Mechanics
        this.pulseMode = 'NORMAL';
        this.pulseTimer = 0;
        this.lockedCells = [];
        this.fallingPieces = [];

        // Input
        this.draggingShape = null;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.touchOffsetY = 100; // Float offset

        this.colors = ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#1abc9c'];
        this.shapesDB = [
            [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
            [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]],
            [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]]
        ];

        // Bind Resize
        window.addEventListener('resize', () => this.resize());
        
        // Bind Input
        this.bindInput();
        
        // Initial setup
        document.getElementById('highscore-val').innerText = this.highScore;
        this.reset();
        
        // Start Loop
        this.loop();
    }

    init() {
        this.resize();
        this.reset();
    }

    resize() {
        // Calculate based on wrapper size (The "Block Blast" Method)
        const rect = this.wrapper.getBoundingClientRect();
        const pixelRatio = window.devicePixelRatio || 1;

        // Use slightly less than 100% to ensure no scrollbars
        const availableW = rect.width * 0.98;
        const availableH = rect.height * 0.98;

        // Set logical CSS size
        this.canvas.style.width = availableW + "px";
        this.canvas.style.height = availableH + "px";

        // Set internal bitmap size
        this.canvas.width = availableW * pixelRatio;
        this.canvas.height = availableH * pixelRatio;
        this.ctx.scale(pixelRatio, pixelRatio);

        // Store logical dimensions for calculation
        this.width = availableW;
        this.height = availableH;

        // Calculate Block Size
        // Needs to fit Grid (10) + Hand area (approx 4.5 blocks high)
        const sizeW = (this.width - (this.GAP * (this.COLS + 1))) / this.COLS;
        const sizeH = (this.height - (this.GAP * (this.ROWS + 1))) / (this.ROWS + 5); 
        this.blockSize = Math.floor(Math.min(sizeW, sizeH));

        // Center Grid
        const gridPixelW = (this.blockSize * this.COLS) + (this.GAP * (this.COLS - 1));
        this.boardX = (this.width - gridPixelW) / 2;
        this.boardY = 10; 

        // Hand Position (Bottom)
        this.handY = this.boardY + (this.blockSize * this.ROWS) + (this.GAP * this.ROWS) + 20;
        this.touchOffsetY = this.blockSize * 2.5;

        // If resizing mid-game, update hand positions
        if(this.hand.length > 0) this.repositionHand();
    }

    reset() {
        this.grid = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(null));
        this.score = 0;
        this.moves = 0;
        this.pulseMode = 'NORMAL';
        this.pulseTimer = 0;
        this.lockedCells = [];
        this.gameState = 'IDLE';
        this.fallingPieces = [];
        this.updateUI();
        document.getElementById('game-over').classList.add('hidden');
        this.spawnHand();
    }

    spawnHand() {
        this.hand = [];
        for(let i=0; i<3; i++) {
            const t = this.shapesDB[Math.floor(Math.random()*this.shapesDB.length)];
            const c = this.colors[Math.floor(Math.random()*this.colors.length)];
            this.hand.push({ 
                matrix: t, color: c, 
                x: 0, y: 0, homeX: 0, homeY: 0, isDragging: false 
            });
        }
        this.repositionHand();
        this.checkGameOver();
    }

    repositionHand() {
        const slotW = this.width / 3;
        this.hand.forEach((s, i) => {
            if(!s.isDragging) {
                const sw = s.matrix[0].length * this.blockSize;
                // Center in slot
                s.homeX = (i * slotW) + (slotW/2) - (sw/2);
                s.homeY = this.handY + this.blockSize; 
                s.x = s.homeX;
                s.y = s.homeY;
            }
        });
    }

    // --- LOGIC ---
    triggerPulse() {
        const m = ['GRAVITY', 'LOCKED', 'ECHO'];
        if(Math.random()<0.3) { this.pulseMode='NORMAL'; this.pulseTimer=0; }
        else {
            this.pulseMode = m[Math.floor(Math.random()*m.length)];
            this.pulseTimer = Math.floor(Math.random()*3)+3;
        }
        if(this.pulseMode==='LOCKED') this.spawnLocks(); else this.lockedCells=[];
        this.updateUI();
    }

    processTurn() {
        this.moves++;
        if(this.pulseMode!=='NORMAL') {
            this.pulseTimer--;
            if(this.pulseTimer<=0) { this.pulseMode='NORMAL'; this.lockedCells=[]; }
        } else if(this.moves%5===0) this.triggerPulse();
        this.updateUI();
    }

    spawnLocks() {
        let n=0, k=0;
        while(n<3 && k<50) {
            let r=Math.floor(Math.random()*this.ROWS), c=Math.floor(Math.random()*this.COLS);
            if(!this.grid[r][c] && !this.isLocked(r,c)) { this.lockedCells.push({r,c}); n++; }
            k++;
        }
    }

    isLocked(r, c) { return this.lockedCells.some(l => l.r===r && l.c===c); },

    checkLines() {
        let rc=[], cc=[];
        for(let r=0; r<this.ROWS; r++) if(this.grid[r].every(v=>v)) rc.push(r);
        for(let c=0; c<this.COLS; c++) {
            let f=true; for(let r=0; r<this.ROWS; r++) if(!this.grid[r][c]) f=false;
            if(f) cc.push(c);
        }
        if(this.pulseMode==='ECHO' && (rc.length>0||cc.length>0)) {
            let er=[];
            rc.forEach(r => { if(r+1<this.ROWS) er.push(r+1); if(r-1>=0) er.push(r-1); });
            rc=[...new Set([...rc, ...er])];
        }
        rc.forEach(r => { for(let c=0; c<this.COLS; c++) this.grid[r][c]=null; });
        cc.forEach(c => { for(let r=0; r<this.ROWS; r++) this.grid[r][c]=null; });
        
        let tot = (rc.length*this.COLS) + (cc.length*this.ROWS);
        if(tot>0) {
            let pts = tot*10; if(rc.length>1||cc.length>1) pts*=2;
            this.score += pts;
            this.updateUI();
        }

        if(this.pulseMode==='GRAVITY') this.startGravity();
        else this.checkGameOver();
    }

    startGravity() {
        this.fallingPieces = [];
        let m=false;
        for(let c=0; c<this.COLS; c++) {
            let w = this.ROWS-1;
            for(let r=this.ROWS-1; r>=0; r--) {
                if(this.isLocked(r,c)) { w=r-1; continue; }
                if(this.grid[r][c]) {
                    if(r!==w) {
                        m=true;
                        this.fallingPieces.push({
                            color: this.grid[r][c], c:c,
                            x: this.boardX+c*(this.blockSize+this.GAP),
                            y: this.boardY+r*(this.blockSize+this.GAP),
                            ty: this.boardY+w*(this.blockSize+this.GAP),
                            tr: w
                        });
                        this.grid[r][c]=null;
                    }
                    w--;
                }
            }
        }
        if(m) this.gameState='ANIMATING'; else this.checkGameOver();
    }

    updateAnim() {
        if(this.gameState!=='ANIMATING') return;
        let act=false; const spd=this.blockSize*0.8; 
        this.fallingPieces.forEach(p => {
            if(p.y < p.ty) { p.y+=spd; act=true; if(p.y>=p.ty) p.y=p.ty; }
        });
        if(!act) {
            this.fallingPieces.forEach(p => this.grid[p.tr][p.c]=p.color);
            this.fallingPieces=[]; this.gameState='IDLE'; this.checkGameOver();
        }
    }

    canPlace(s, gr, gc) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    let tr=gr+r, tc=gc+c;
                    if(tr<0||tr>=this.ROWS||tc<0||tc>=this.COLS) return false;
                    if(this.grid[tr][tc] || this.isLocked(tr,tc)) return false;
                }
            }
        }
        return true;
    }

    placeShape(s, gr, gc) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) this.grid[gr+r][gc+c]=s.color;
            }
        }
        this.score += s.matrix.flat().filter(x=>x).length;
        this.updateUI();
        this.hand = this.hand.filter(h => h!==s);
        this.processTurn();
        this.checkLines();
        if(this.hand.length===0) this.spawnHand();
    }

    checkGameOver() {
        if(this.gameState==='ANIMATING'||this.hand.length===0) return;
        let pos=false;
        for(let s of this.hand) {
            for(let r=0; r<this.ROWS; r++) {
                for(let c=0; c<this.COLS; c++) if(this.canPlace(s,r,c)) { pos=true; break; }
                if(pos) break;
            }
            if(pos) break;
        }
        if(!pos) {
            this.gameState='GAMEOVER';
            document.getElementById('final-score').innerText=this.score;
            if(this.score>this.highScore) {
                this.highScore=this.score;
                localStorage.setItem('pulseHigh', this.highScore);
            }
            document.getElementById('game-over').classList.remove('hidden');
        }
    }
    
    updateUI() {
        document.getElementById('score-val').innerText=this.score;
        document.getElementById('highscore-val').innerText=this.highScore;
        const b = document.getElementById('pulse-indicator');
        b.className = '';
        if(this.pulseMode==='NORMAL') { b.classList.add('pulse-normal'); b.innerText="STATUS: NORMAL"; }
        else {
            b.classList.add(`pulse-${this.pulseMode.toLowerCase()}`);
            b.innerText = `${this.pulseMode} (${this.pulseTimer})`;
        }
    }

    // --- INPUT ---
    getPointer(e) {
        // Correctly maps touch coordinates relative to canvas
        const r = this.canvas.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: cx - r.left, y: cy - r.top };
    }

    bindInput() {
        const start = (e) => {
            if(this.gameState!=='IDLE') return;
            const p = this.getPointer(e);
            const pad = 30;
            for(let s of this.hand) {
                const w = s.matrix[0].length * this.blockSize;
                const h = s.matrix.length * this.blockSize;
                if(p.x >= s.x-pad && p.x <= s.x+w+pad && p.y >= s.y-pad && p.y <= s.y+h+pad) {
                    this.draggingShape = s;
                    s.isDragging = true;
                    this.dragOffsetX = p.x - s.x;
                    this.dragOffsetY = p.y - s.y;
                    break;
                }
            }
        };

        const move = (e) => {
            if(!this.draggingShape) return;
            e.preventDefault();
            const p = this.getPointer(e);
            this.draggingShape.x = p.x - this.dragOffsetX;
            // Float above finger
            this.draggingShape.y = p.y - this.dragOffsetY - this.touchOffsetY;
        };

        const end = (e) => {
            if(!this.draggingShape) return;
            const s = this.draggingShape;
            const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
            const cy = s.y + (s.matrix.length * this.blockSize)/2;
            
            // Calculate grid position based on center
            const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
            const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));

            if(this.canPlace(s, gr, gc)) this.placeShape(s, gr, gc);
            else { s.x = s.homeX; s.y = s.homeY; }
            
            s.isDragging = false;
            this.draggingShape = null;
        };

        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end, {passive: false});
    }

    // --- RENDER ---
    loop() {
        this.updateAnim();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    draw() {
        this.ctx.clearRect(0,0,this.width,this.height);

        // Draw Board
        for(let r=0; r<this.ROWS; r++) {
            for(let c=0; c<this.COLS; c++) {
                const x = this.boardX + c*(this.blockSize+this.GAP);
                const y = this.boardY + r*(this.blockSize+this.GAP);
                
                this.ctx.fillStyle = '#2a2a30';
                this.roundRect(x,y,this.blockSize,this.blockSize,4);
                this.ctx.fill();

                if(this.isLocked(r,c)) {
                    this.ctx.fillStyle='#111'; this.ctx.fill();
                    this.ctx.strokeStyle='#c0392b'; this.ctx.lineWidth=2;
                    this.ctx.strokeRect(x+4,y+4,this.blockSize-8,this.blockSize-8);
                }

                if(this.grid[r][c]) this.drawBlock(x,y,this.grid[r][c]);
            }
        }

        // Falling Pieces
        this.fallingPieces.forEach(p => this.drawBlock(p.x, p.y, p.color));

        // Separator
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(0, this.handY-10, this.width, 2);

        // Hand
        this.hand.forEach(s => {
            if(s.isDragging) {
                // Ghost
                const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
                const cy = s.y + (s.matrix.length * this.blockSize)/2;
                const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
                const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));
                if(this.canPlace(s, gr, gc)) {
                    this.ctx.globalAlpha = 0.3;
                    this.drawShapeAt(s, this.boardX+gc*(this.blockSize+this.GAP), this.boardY+gr*(this.blockSize+this.GAP), '#fff');
                    this.ctx.globalAlpha = 1.0;
                }
            }
            this.drawShape(s);
        });

        // Pulse Border
        if(this.pulseMode!=='NORMAL') {
            this.ctx.strokeStyle = this.pulseMode==='GRAVITY'?'#f39c12':this.pulseMode==='LOCKED'?'#e74c3c':'#9b59b6';
            this.ctx.lineWidth = 4;
            this.ctx.strokeRect(this.boardX-3, this.boardY-3, (this.blockSize+this.GAP)*this.COLS+6, (this.blockSize+this.GAP)*this.ROWS+6);
        }
    }

    drawBlock(x, y, c) {
        this.ctx.fillStyle = c;
        this.roundRect(x,y,this.blockSize,this.blockSize,4);
        this.ctx.fill();
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.fillRect(x+2,y+2,this.blockSize-4,this.blockSize*0.3);
    }

    drawShape(s) {
        const size = s.isDragging ? this.blockSize : this.blockSize*0.9;
        const g = s.isDragging ? this.GAP : 2;
        if(s.isDragging) { this.ctx.shadowColor='rgba(0,0,0,0.5)'; this.ctx.shadowBlur=15; this.ctx.shadowOffsetY=15; }
        
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    this.ctx.fillStyle = s.color;
                    this.roundRect(s.x + c*(size+g), s.y + r*(size+g), size, size, 4);
                    this.ctx.fill();
                }
            }
        }
        this.ctx.shadowColor='transparent'; this.ctx.shadowBlur=0; this.ctx.shadowOffsetY=0;
    }

    drawShapeAt(s, x, y, c) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    this.ctx.fillStyle = c;
                    this.roundRect(x + c*(this.blockSize+this.GAP), y + r*(this.blockSize+this.GAP), this.blockSize, this.blockSize, 4);
                    this.ctx.fill();
                }
            }
        }
    }

    roundRect(x, y, w, h, r) {
        this.ctx.beginPath();
        this.ctx.moveTo(x+r, y); this.ctx.lineTo(x+w-r, y); this.ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        this.ctx.lineTo(x+w, y+h-r); this.ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        this.ctx.lineTo(x+r, y+h); this.ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        this.ctx.lineTo(x, y+r); this.ctx.quadraticCurveTo(x, y, x+r, y);
        this.ctx.closePath();
    }
}

let GameApp;
window.onload = () => {
    // FORCE HEIGHT LOGIC FROM REFERENCE
    const setH = () => document.body.style.height = window.innerHeight + "px";
    window.addEventListener("resize", setH);
    setH();
    
    GameApp = new PulseGrid();
};
</script>
</body>
</html>
