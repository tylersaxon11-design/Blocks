<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Pulse Grid</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-bg: #1e1e24;
            --highlight: #00fff2;
            --text-color: #ffffff;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Critical for mobile game feel */
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: var(--font-main);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Height is set by JS to handle mobile address bars */
            height: 100vh; 
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* Limits width on desktop */
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
        }

        /* --- UI Header --- */
        #ui-header {
            width: 95%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            flex-shrink: 0;
            z-index: 10;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 15px;
            border-radius: 12px;
            min-width: 90px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .label { font-size: 0.75rem; text-transform: uppercase; color: #aaa; letter-spacing: 1px; }
        .value { font-size: 1.4rem; font-weight: 800; color: #fff; }

        #pulse-indicator {
            width: 95%;
            padding: 10px 0;
            background: #222;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
            border: 2px solid #444;
            transition: all 0.3s ease;
            margin-bottom: 5px;
            flex-shrink: 0;
            z-index: 10;
            text-transform: uppercase;
        }

        /* --- Canvas --- */
        canvas {
            border-radius: 8px;
            width: 96%; /* CSS width */
            flex-grow: 1; /* Fills remaining space */
            background-color: var(--grid-bg);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        /* --- Overlays --- */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 18, 18, 0.96);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.3s;
            text-align: center;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 { font-size: 3rem; margin: 0 0 10px 0; color: var(--highlight); text-shadow: 0 0 20px rgba(0,255,242,0.5); }
        p { font-size: 1.1rem; color: #ccc; margin: 10px 20px; line-height: 1.5; max-width: 400px; }

        button {
            padding: 18px 36px;
            font-size: 1.2rem;
            background: var(--highlight);
            border: none;
            border-radius: 12px;
            color: #000;
            font-weight: 800;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 242, 0.3);
            text-transform: uppercase;
        }
        button:active { transform: scale(0.95); }

        /* Status Colors */
        .pulse-normal { border-color: #555; color: #fff; }
        .pulse-gravity { border-color: #f39c12; color: #f39c12; background: rgba(243, 156, 18, 0.1); }
        .pulse-locked { border-color: #e74c3c; color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .pulse-echo { border-color: #9b59b6; color: #9b59b6; background: rgba(155, 89, 182, 0.1); }

    </style>
</head>
<body>

<div id="game-container">
    
    <!-- UI Header -->
    <div id="ui-header">
        <div class="stat-box">
            <div class="label">Score</div>
            <div class="value" id="score-val">0</div>
        </div>
        <div class="stat-box">
            <div class="label">Best</div>
            <div class="value" id="highscore-val">0</div>
        </div>
    </div>

    <!-- Status Bar -->
    <div id="pulse-indicator" class="pulse-normal">STATUS: NORMAL</div>

    <!-- The Game Board -->
    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen -->
    <div id="start-screen" class="modal-overlay">
        <h1>PULSE GRID</h1>
        <p>Drag blocks to fill the grid.</p>
        <p style="font-size: 0.9rem; color: #888;">Blocks float above your finger for visibility.</p>
        <button id="start-btn">TAP TO START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over" class="modal-overlay hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 0 20px #e74c3c;">GRID LOCKED</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="Game.reset()">PLAY AGAIN</button>
    </div>

</div>

<script>
/**
 * PULSE GRID - OPTIMIZED MOBILE LAYOUT
 * Uses dynamic viewport sizing and devicePixelRatio scaling
 */

const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    
    // Config
    COLS: 10,
    ROWS: 10,
    GAP: 2,
    
    // Dynamic Dimensions (Calculated in resize)
    width: 0,
    height: 0,
    pixelRatio: 1,
    blockSize: 0,
    boardX: 0,
    boardY: 0,
    handY: 0,
    
    // State
    grid: [],
    hand: [],
    score: 0,
    highScore: localStorage.getItem('pulseHigh') || 0,
    moves: 0,
    gameState: 'START', // START, IDLE, ANIMATING, GAMEOVER
    
    // Dragging
    draggingShape: null,
    dragOffsetX: 0,
    dragOffsetY: 0,
    touchOffsetY: 100, // Visual offset for visibility

    // Pulse Mechanics
    pulseMode: 'NORMAL',
    pulseTimer: 0,
    lockedCells: [],
    fallingPieces: [],

    // Colors
    colors: ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#1abc9c'],
    
    // Shapes Database
    shapesDB: [
        [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]],
        [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]],
        [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]]
    ],

    init() {
        this.ctx = this.canvas.getContext('2d');
        
        // Update High Score UI
        document.getElementById('highscore-val').innerText = this.highScore;

        // Resize Listener
        window.addEventListener('resize', () => this.resize());
        this.resize(); // Initial calculation

        // Input Listeners
        this.bindInput();

        // Start Loop
        requestAnimationFrame(() => this.loop());
        
        // Initial Game Setup
        this.reset();
    },

    resize() {
        // 1. Force Body Height (The "Block Blast" fix)
        document.body.style.height = window.innerHeight + "px";

        // 2. Get Container Dimensions
        const container = document.getElementById('game-container');
        const rect = container.getBoundingClientRect();
        
        // Calculate available space for canvas (Container - UI)
        // We look at the space remaining in the flex container
        // But simply taking the container height minus header heights is safer
        const headerH = document.getElementById('ui-header').offsetHeight;
        const statusH = document.getElementById('pulse-indicator').offsetHeight;
        const totalUIHeight = headerH + statusH + 30; // + padding

        const availableW = rect.width * 0.96; // 96% of container width
        const availableH = rect.height - totalUIHeight - 20; // Bottom buffer

        // 3. Handle High DPI (Retina)
        this.pixelRatio = window.devicePixelRatio || 1;
        
        // Set Logical (CSS) Size
        this.canvas.style.width = availableW + 'px';
        this.canvas.style.height = availableH + 'px';

        // Set Internal (Bitmap) Size
        this.canvas.width = availableW * this.pixelRatio;
        this.canvas.height = availableH * this.pixelRatio;
        
        // Scale Context
        this.ctx.scale(this.pixelRatio, this.pixelRatio);

        // 4. Calculate Grid Dimensions
        this.width = availableW;
        this.height = availableH;

        // Calculate maximum possible block size to fit width OR height
        // Height needs to fit: Grid (ROWS) + Gap + Divider + Hand (approx 4 blocks)
        const sizeBasedOnWidth = (this.width - (this.GAP * (this.COLS + 1))) / this.COLS;
        const sizeBasedOnHeight = (this.height - (this.GAP * (this.ROWS + 1))) / (this.ROWS + 5); 
        
        this.blockSize = Math.floor(Math.min(sizeBasedOnWidth, sizeBasedOnHeight));

        // Center the Grid Horizontally
        const totalGridW = (this.blockSize * this.COLS) + (this.GAP * (this.COLS - 1));
        this.boardX = (this.width - totalGridW) / 2;
        this.boardY = 10; // Top padding inside canvas

        // Calculate Hand Y Position (Below Grid)
        this.handY = this.boardY + (this.blockSize * this.ROWS) + (this.GAP * this.ROWS) + 30;

        // Update touch offset based on block size
        this.touchOffsetY = this.blockSize * 2.5;

        // Re-position existing hand shapes if resize happens mid-game
        if(this.hand.length > 0) {
            this.repositionHand();
        }
    },

    bindInput() {
        const start = (e) => this.handleStart(e);
        const move = (e) => this.handleMove(e);
        const end = (e) => this.handleEnd(e);

        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        
        this.canvas.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end, {passive: false});
        
        // Start Button
        const btn = document.getElementById('start-btn');
        const triggerStart = (e) => {
            e.preventDefault();
            this.toggleFullscreen();
            document.getElementById('start-screen').classList.add('hidden');
            this.resize(); // Force resize after fullscreen transition
            this.gameState = 'IDLE';
        };
        btn.addEventListener('click', triggerStart);
        btn.addEventListener('touchstart', triggerStart);
    },

    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => console.log(err));
        }
    },

    reset() {
        this.grid = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(null));
        this.score = 0;
        this.moves = 0;
        this.pulseMode = 'NORMAL';
        this.pulseTimer = 0;
        this.lockedCells = [];
        this.gameState = 'IDLE';
        this.fallingPieces = [];
        
        this.updateUI();
        document.getElementById('game-over').classList.add('hidden');
        
        this.spawnHand();
    },

    spawnHand() {
        this.hand = [];
        for(let i=0; i<3; i++) {
            const t = this.shapesDB[Math.floor(Math.random() * this.shapesDB.length)];
            const c = this.colors[Math.floor(Math.random() * this.colors.length)];
            
            // Create object
            this.hand.push({
                matrix: t,
                color: c,
                x: 0, y: 0, // Set in repositionHand
                homeX: 0, homeY: 0,
                isDragging: false
            });
        }
        this.repositionHand();
        this.checkGameOver();
    },

    repositionHand() {
        const slotW = this.width / 3;
        this.hand.forEach((shape, i) => {
            if(!shape.isDragging) {
                const shapePixelW = shape.matrix[0].length * this.blockSize;
                const shapePixelH = shape.matrix.length * this.blockSize;
                
                const cx = (i * slotW) + (slotW / 2);
                const cy = this.handY + (this.blockSize * 1.5); // Center in hand area

                shape.homeX = cx - shapePixelW/2;
                shape.homeY = cy - shapePixelH/2;
                shape.x = shape.homeX;
                shape.y = shape.homeY;
            }
        });
    },

    // --- LOGIC ---

    triggerPulse() {
        const modes = ['GRAVITY', 'LOCKED', 'ECHO'];
        if (Math.random() < 0.25) {
            this.pulseMode = 'NORMAL';
            this.pulseTimer = 0;
        } else {
            this.pulseMode = modes[Math.floor(Math.random() * modes.length)];
            this.pulseTimer = Math.floor(Math.random() * 3) + 3;
        }

        if (this.pulseMode === 'LOCKED') this.spawnLockedCells();
        else this.lockedCells = [];
        
        this.updateUI();
    },

    processTurn() {
        this.moves++;
        if (this.pulseMode !== 'NORMAL') {
            this.pulseTimer--;
            if (this.pulseTimer <= 0) {
                this.pulseMode = 'NORMAL';
                this.lockedCells = [];
            }
        } else if (this.moves % 5 === 0) {
            this.triggerPulse();
        }
        this.updateUI();
    },

    spawnLockedCells() {
        let count = 0, tries = 0;
        while(count < 3 && tries < 50) {
            let r = Math.floor(Math.random() * this.ROWS);
            let c = Math.floor(Math.random() * this.COLS);
            if (!this.grid[r][c] && !this.isLocked(r,c)) {
                this.lockedCells.push({r, c});
                count++;
            }
            tries++;
        }
    },

    isLocked(r, c) {
        return this.lockedCells.some(cell => cell.r === r && cell.c === c);
    },

    checkLines() {
        let rClr = [], cClr = [];

        // Find full rows/cols
        for(let r=0; r<this.ROWS; r++) if(this.grid[r].every(c => c !== null)) rClr.push(r);
        for(let c=0; c<this.COLS; c++) {
            let full = true;
            for(let r=0; r<this.ROWS; r++) if(this.grid[r][c] === null) { full=false; break; }
            if(full) cClr.push(c);
        }

        // Echo Effect
        if (this.pulseMode === 'ECHO' && (rClr.length > 0 || cClr.length > 0)) {
            let echoR = [];
            rClr.forEach(r => {
                if(r+1 < this.ROWS && !rClr.includes(r+1)) echoR.push(r+1);
                if(r-1 >= 0 && !rClr.includes(r-1)) echoR.push(r-1);
            });
            rClr = [...rClr, ...echoR];
        }

        // Clear Data
        rClr.forEach(r => { for(let c=0; c<this.COLS; c++) this.grid[r][c] = null; });
        cClr.forEach(c => { for(let r=0; r<this.ROWS; r++) this.grid[r][c] = null; });

        // Score
        let total = (rClr.length * this.COLS) + (cClr.length * this.ROWS);
        if(total > 0) {
            let pts = total * 10;
            if(rClr.length > 1 || cClr.length > 1) pts *= 2;
            this.addScore(pts);
        }

        if(this.pulseMode === 'GRAVITY') this.startGravity();
        else this.checkGameOver();
    },

    startGravity() {
        this.fallingPieces = [];
        let moved = false;
        
        for(let c=0; c<this.COLS; c++) {
            let writeRow = this.ROWS - 1;
            for(let r=this.ROWS-1; r>=0; r--) {
                if(this.isLocked(r, c)) {
                    writeRow = r - 1;
                    continue;
                }
                if(this.grid[r][c] !== null) {
                    if(r !== writeRow) {
                        moved = true;
                        this.fallingPieces.push({
                            color: this.grid[r][c],
                            c: c,
                            x: this.boardX + c * (this.blockSize + this.GAP),
                            y: this.boardY + r * (this.blockSize + this.GAP),
                            targetY: this.boardY + writeRow * (this.blockSize + this.GAP),
                            targetR: writeRow
                        });
                        this.grid[r][c] = null;
                    }
                    writeRow--;
                }
            }
        }
        
        if(moved) this.gameState = 'ANIMATING';
        else this.checkGameOver();
    },

    updateAnimation() {
        if(this.gameState !== 'ANIMATING') return;
        
        let active = false;
        const speed = this.blockSize * 0.8; // Fast fall

        this.fallingPieces.forEach(p => {
            if(p.y < p.targetY) {
                p.y += speed;
                active = true;
                if(p.y >= p.targetY) p.y = p.targetY;
            }
        });

        if(!active) {
            this.fallingPieces.forEach(p => {
                this.grid[p.targetR][p.c] = p.color;
            });
            this.fallingPieces = [];
            this.gameState = 'IDLE';
            this.checkGameOver();
        }
    },

    canPlace(shape, gr, gc) {
        for(let r=0; r<shape.matrix.length; r++) {
            for(let c=0; c<shape.matrix[r].length; c++) {
                if(shape.matrix[r][c] === 1) {
                    let tr = gr + r;
                    let tc = gc + c;
                    if(tr < 0 || tr >= this.ROWS || tc < 0 || tc >= this.COLS) return false;
                    if(this.grid[tr][tc] !== null) return false;
                    if(this.isLocked(tr, tc)) return false;
                }
            }
        }
        return true;
    },

    placeShape(shape, gr, gc) {
        for(let r=0; r<shape.matrix.length; r++) {
            for(let c=0; c<shape.matrix[r].length; c++) {
                if(shape.matrix[r][c] === 1) {
                    this.grid[gr + r][gc + c] = shape.color;
                }
            }
        }
        this.addScore(shape.matrix.flat().filter(x=>x).length);
        this.hand = this.hand.filter(s => s !== shape);
        
        this.processTurn();
        this.checkLines();
        
        if(this.hand.length === 0) this.spawnHand();
    },

    checkGameOver() {
        if(this.gameState === 'ANIMATING') return;
        if(this.hand.length === 0) return;

        let possible = false;
        for(let s of this.hand) {
            for(let r=0; r<this.ROWS; r++) {
                for(let c=0; c<this.COLS; c++) {
                    if(this.canPlace(s, r, c)) { possible = true; break; }
                }
                if(possible) break;
            }
            if(possible) break;
        }

        if(!possible) {
            this.gameState = 'GAMEOVER';
            document.getElementById('final-score').innerText = this.score;
            if(this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('pulseHigh', this.highScore);
            }
            document.getElementById('game-over').classList.remove('hidden');
        }
    },

    addScore(pts) {
        this.score += pts;
        this.updateUI();
    },

    updateUI() {
        document.getElementById('score-val').innerText = this.score;
        document.getElementById('highscore-val').innerText = this.highScore;
        
        const ind = document.getElementById('pulse-indicator');
        ind.className = '';
        if(this.pulseMode === 'NORMAL') {
            ind.classList.add('pulse-normal');
            ind.innerText = "STATUS: NORMAL";
        } else {
            ind.classList.add(`pulse-${this.pulseMode.toLowerCase()}`);
            let t = this.pulseMode === 'GRAVITY' ? 'GRAVITY SHIFT' : 
                    this.pulseMode === 'LOCKED' ? 'GRID LOCKED' : 'ECHO BLAST';
            ind.innerText = `${t} (${this.pulseTimer})`;
        }
    },

    // --- INPUT ---

    getPointerPos(e) {
        // Since we scale the ctx, we can just use Client coordinates minus Canvas offset
        // But we want logic coordinates relative to the canvas 0,0
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    },

    handleStart(e) {
        if(this.gameState !== 'IDLE') return;
        const pos = this.getPointerPos(e);

        // Check Hand Collisions
        for(let s of this.hand) {
            const w = s.matrix[0].length * this.blockSize;
            const h = s.matrix.length * this.blockSize;
            // Generous hit box
            const pad = 30;
            if(pos.x >= s.x - pad && pos.x <= s.x + w + pad &&
               pos.y >= s.y - pad && pos.y <= s.y + h + pad) {
                
                this.draggingShape = s;
                s.isDragging = true;
                // Grab offset
                this.dragOffsetX = pos.x - s.x;
                this.dragOffsetY = pos.y - s.y;
                break;
            }
        }
    },

    handleMove(e) {
        if(!this.draggingShape) return;
        e.preventDefault(); // Prevent scrolling
        const pos = this.getPointerPos(e);

        this.draggingShape.x = pos.x - this.dragOffsetX;
        // Float above finger logic
        this.draggingShape.y = pos.y - this.dragOffsetY - this.touchOffsetY;
    },

    handleEnd(e) {
        if(!this.draggingShape) return;

        // Calculate closest grid position
        // Center of the shape logic:
        const s = this.draggingShape;
        const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
        const cy = s.y + (s.matrix.length * this.blockSize)/2;

        const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
        const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));

        // Use top-left precision check as backup
        // Or simply trust the rounded center
        if(this.canPlace(s, gr, gc)) {
            this.placeShape(s, gr, gc);
        } else {
            // Spring back
            s.x = s.homeX;
            s.y = s.homeY;
        }

        s.isDragging = false;
        this.draggingShape = null;
    },

    // --- DRAW ---

    loop() {
        this.updateAnimation();
        this.draw();
        requestAnimationFrame(() => this.loop());
    },

    draw() {
        // Clear
        this.ctx.clearRect(0, 0, this.width, this.height);

        // Draw Grid
        for(let r=0; r<this.ROWS; r++) {
            for(let c=0; c<this.COLS; c++) {
                const x = this.boardX + c * (this.blockSize + this.GAP);
                const y = this.boardY + r * (this.blockSize + this.GAP);
                
                // Empty Slot
                this.ctx.fillStyle = '#2a2a30';
                this.drawRoundedRect(x, y, this.blockSize, this.blockSize, 4);
                this.ctx.fill();

                // Locked
                if(this.isLocked(r, c)) {
                    this.ctx.fillStyle = '#1a1a1a';
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#c0392b';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x+5, y+5); this.ctx.lineTo(x+this.blockSize-5, y+this.blockSize-5);
                    this.ctx.moveTo(x+this.blockSize-5, y+5); this.ctx.lineTo(x+5, y+this.blockSize-5);
                    this.ctx.stroke();
                }

                // Filled
                if(this.grid[r][c]) {
                    this.drawBlock(x, y, this.grid[r][c]);
                }
            }
        }

        // Draw Falling Pieces
        this.fallingPieces.forEach(p => {
            this.drawBlock(p.x, p.y, p.color);
        });

        // Draw Divider
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(0, this.handY - 15, this.width, 2);

        // Draw Hand
        this.hand.forEach(s => {
            // Draw Ghost if dragging
            if(s.isDragging) {
                const cx = s.x + (s.matrix[0].length * this.blockSize)/2;
                const cy = s.y + (s.matrix.length * this.blockSize)/2;
                const gr = Math.round((cy - this.boardY - this.blockSize/2) / (this.blockSize + this.GAP));
                const gc = Math.round((cx - this.boardX - this.blockSize/2) / (this.blockSize + this.GAP));

                if(this.canPlace(s, gr, gc)) {
                    this.ctx.globalAlpha = 0.3;
                    this.drawShapeAt(s, this.boardX + gc*(this.blockSize+this.GAP), this.boardY + gr*(this.blockSize+this.GAP), '#fff');
                    this.ctx.globalAlpha = 1.0;
                }
            }
            this.drawShape(s);
        });
        
        // Border for Pulse
        if(this.pulseMode !== 'NORMAL') {
            const gridW = this.COLS * (this.blockSize+this.GAP) - this.GAP;
            const gridH = this.ROWS * (this.blockSize+this.GAP) - this.GAP;
            this.ctx.strokeStyle = this.pulseMode === 'GRAVITY' ? '#f39c12' : 
                                   this.pulseMode === 'LOCKED' ? '#e74c3c' : '#9b59b6';
            this.ctx.lineWidth = 4;
            this.ctx.strokeRect(this.boardX - 4, this.boardY - 4, gridW + 8, gridH + 8);
        }
    },

    drawBlock(x, y, color) {
        this.ctx.fillStyle = color;
        this.drawRoundedRect(x, y, this.blockSize, this.blockSize, 4);
        this.ctx.fill();
        
        // Shine
        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
        this.ctx.fillRect(x+2, y+2, this.blockSize-4, this.blockSize*0.3);
    },

    drawShape(s) {
        if(s.isDragging) {
            this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
            this.ctx.shadowBlur = 15;
            this.ctx.shadowOffsetY = 15;
        }
        
        const size = s.isDragging ? this.blockSize : this.blockSize * 0.9; // Scale down slightly in hand
        const gap = s.isDragging ? this.GAP : 2;

        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    const bx = s.x + c * (size + gap);
                    const by = s.y + r * (size + gap);
                    
                    this.ctx.fillStyle = s.color;
                    this.drawRoundedRect(bx, by, size, size, 4);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    this.ctx.fillRect(bx+2, by+2, size-4, size*0.3);
                }
            }
        }
        
        this.ctx.shadowColor = 'transparent';
        this.ctx.shadowBlur = 0;
        this.ctx.shadowOffsetY = 0;
    },

    drawShapeAt(s, sx, sy, color) {
        for(let r=0; r<s.matrix.length; r++) {
            for(let c=0; c<s.matrix[r].length; c++) {
                if(s.matrix[r][c]) {
                    const bx = sx + c * (this.blockSize + this.GAP);
                    const by = sy + r * (this.blockSize + this.GAP);
                    this.ctx.fillStyle = color || s.color;
                    this.drawRoundedRect(bx, by, this.blockSize, this.blockSize, 4);
                    this.ctx.fill();
                }
            }
        }
    },

    drawRoundedRect(x, y, w, h, r) {
        this.ctx.beginPath();
        this.ctx.moveTo(x+r, y);
        this.ctx.lineTo(x+w-r, y);
        this.ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        this.ctx.lineTo(x+w, y+h-r);
        this.ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        this.ctx.lineTo(x+r, y+h);
        this.ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        this.ctx.lineTo(x, y+r);
        this.ctx.quadraticCurveTo(x, y, x+r, y);
        this.ctx.closePath();
    }
};

window.onload = () => {
    // Initial Fullscreen/Resize trigger
    const setH = () => document.body.style.height = window.innerHeight + "px";
    window.addEventListener("resize", setH);
    setH();
    
    Game.init();
};

</script>
</body>
</html>
